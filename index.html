<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Hexo
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="vue-路由原理"
  class="article article-type-vue"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/28/%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/"
    >VUE 路由原理</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/28/%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2021-01-28T11:54:11.000Z" itemprop="datePublished">2021-01-28</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><ol>
<li>vue-router是让单页面拥有多页面的效果；一个url对应一个页面</li>
<li>为什么使用vue-router不用a标签：a标签也可以跳转但是会刷新页面，但是vue-router可以解决这种问题，url变化时不刷新页面，而且可以监听变化           </li>
<li>原理：分两种模式：history、hash</li>
</ol>
<h3 id="两种模式用法"><a href="#两种模式用法" class="headerlink" title="两种模式用法"></a>两种模式用法</h3><p><strong>history接口不继承任何方法</strong><br><em>属性：</em></p>
<ol>
<li>history.length:只读的，返回一个整数，该整数表示会话历史中元素的数目，包括当前加载的页。例如，在一个新的选项卡加载的一个页面中，这个属性返回1。</li>
<li>history.state：只读的，返回一个表示历史堆栈顶部的状态的值。</li>
</ol>
<p><em>方法：接口不继承任何方法。</em></p>
<ol>
<li>history.back():在浏览器历史记录里前往上一页,等价于 history.go(-1).</li>
<li>history.forward():在浏览器历史记录里前往下一页，等价于 history.go(1).</li>
<li>history.go():通过当前页面的相对位置从浏览器历史记录( 会话记录 )加载页面。比如：参数为-1的时候为上一页，参数为1的时候为下一页. 当整数参数超出界限时,例如: 如果当前页为第一页，前面已经没有页面了，我传参的值为-1，那么这个方法没有任何效果也不会报错。调用没有参数的 go() 方法或者不是整数的参数时也没有效果。</li>
<li>history.pushState(): 方法向当前浏览器会话的历史堆栈中添加一个状态;</li>
</ol>
<p><strong>语法:</strong><br>history.pushState(state, title[, url])<br><strong>参数:</strong></p>
<ol>
<li>state:状态对象是一个JavaScript对象，它与pushState()创建的新历史记录条目相关联。 每当用户导航到新状态时，都会触发popstate事件，并且该事件的状态属性包含历史记录条目的状态对象的副本。</li>
<li>title:在此处传递空字符串应该可以防止将来对方法的更改。</li>
<li>url:新历史记录条目的URL由此参数指定。 请注意，浏览器不会在调用pushState() 之后尝试加载此URL，但可能会稍后尝试加载URL{不会加载页面，不会刷新}</li>
</ol>
<p><strong>hash模式</strong><br><em>即地址栏 URL 中的 # 符号,这个#就是hash符号</em><br><strong>特点</strong><br>hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。<br><strong>原理</strong><br>路由的hash模式其实是利用了window.onhashchange事件，也就是说你的url中的hash值（#后面的值）如果有变化，就会自动调用hashchange的监听事件，在hashchange的监听事件内可以得到改变后的url，这样能够找到对应页面进行加载</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="css-样式语法问题"
  class="article article-type-css"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/27/%E6%A0%B7%E5%BC%8F%E8%AF%AD%E6%B3%95%E9%97%AE%E9%A2%98/"
    >CSS样式语法问题</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/27/%E6%A0%B7%E5%BC%8F%E8%AF%AD%E6%B3%95%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2021-01-27T10:01:24.000Z" itemprop="datePublished">2021-01-27</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Display-none与Visibility-hidden有什么区别"><a href="#Display-none与Visibility-hidden有什么区别" class="headerlink" title="Display:none与Visibility:hidden有什么区别"></a>Display:none与Visibility:hidden有什么区别</h2><p><strong>在css中，设置元素的隐藏的方式，主要有两种，一种是display:none，一种是visibility:hidden</strong><br><em>区别</em></p>
<ol>
<li>空间占据</li>
</ol>
<ul>
<li>首先是空间占据方面，设置了display:none 样式的元素，在文档流中是不占位置的，而且，浏览器也不会解析这个元素；而设置了visibility:hidden样式的元素，在文档流中仍然占位，可以理解为，只是把透明度变成了0;</li>
<li>举例说明:比如，我这里有2个ul，每个ul下面，有4个li，而且，对每个li都做了编号。现在我们对li3设置了display:none样式，而对li7设置了visibility:hidden属性;</li>
<li>结果就会是:隐藏li3后，li3在页面消失且不占位，li4将li3的位置霸占了，可以理解为彻底消失；而隐藏li7后，从视觉上来看，li7是消失了，但是li7的位置还保留着，它的位置别人不能随便占。</li>
</ul>
<ol start="2">
<li>株连型</li>
</ol>
<ul>
<li>株连是什么意思呢？大家应该都听过株连九族这个词，株连其实可以理解为，自己啥也没干，就被连累了。这个株连性，主要体现在父子关系的结构中;</li>
<li>举例说明:有2个ul，每个ul下面，有有4个li，而且，对每个li都做了编号。在li3和li7下面呢，又有一个div，写着“我是li3的儿子”、“我是li7的儿子”。我对li3设置display:none样式，而对li7设置visibility:hidden属性</li>
<li>结果:li3和它的儿子，一起彻底消失，都不占位；而li7和它的儿子，都是视觉上消失了，但位置还在;</li>
<li>总结:一旦父节点元素应用了 display:none，父节点及其子孙节点元素全部不可见</li>
</ul>
<h2 id="CSS-hack的原理及常用hack"><a href="#CSS-hack的原理及常用hack" class="headerlink" title="CSS hack的原理及常用hack"></a>CSS hack的原理及常用hack</h2><p><strong>原理:利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。常见的hack有1.属性hack、2.选择器hack、3.IE条件注释</strong></p>
<ol>
<li>IE条件:适用于[IE5,IE9]常见格式:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[<span class="keyword">if</span> IE <span class="number">6</span>]&gt;</span><br><span class="line">Special instructions <span class="keyword">for</span> IE <span class="number">6</span> here</span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure></li>
<li>选择器hack:不同浏览器对选择器的支持不一样<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***** Selector Hacks ******/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* IE6 and below */</span></span><br><span class="line">* html #uno  &#123; <span class="attr">color</span>: red &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IE7 */</span></span><br><span class="line">*:first-child+html #dos &#123; <span class="attr">color</span>: red &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IE7, FF, Saf, Opera  */</span></span><br><span class="line">html&gt;body #tres &#123; <span class="attr">color</span>: red &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IE8, FF, Saf, Opera (Everything but IE 6,7) */</span></span><br><span class="line">html&gt;<span class="comment">/**/</span>body #cuatro &#123; <span class="attr">color</span>: red &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Opera 9.27 and below, safari 2 */</span></span><br><span class="line">html:first-child #cinco &#123; <span class="attr">color</span>: red &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Safari 2-3 */</span></span><br><span class="line">html[xmlns*=<span class="string">&quot;&quot;</span>] body:last-child #seis &#123; <span class="attr">color</span>: red &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* safari 3+, chrome 1+, opera9+, ff 3.5+ */</span></span><br><span class="line">body:nth-<span class="keyword">of</span>-type(<span class="number">1</span>) #siete &#123; <span class="attr">color</span>: red &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* safari 3+, chrome 1+, opera9+, ff 3.5+ */</span></span><br><span class="line">body:first-<span class="keyword">of</span>-type #ocho &#123;  <span class="attr">color</span>: red &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* saf3+, chrome1+ */</span></span><br><span class="line">@media screen and (-webkit-min-device-pixel-ratio:<span class="number">0</span>) &#123;</span><br><span class="line"> #diez  &#123; <span class="attr">color</span>: red  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* iPhone / mobile webkit */</span></span><br><span class="line">@media screen and (max-device-width: 480px) &#123;</span><br><span class="line"> #veintiseis &#123; <span class="attr">color</span>: red  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Safari 2 - 3.1 */</span></span><br><span class="line">html[xmlns*=<span class="string">&quot;&quot;</span>]:root #trece  &#123; <span class="attr">color</span>: red  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Safari 2 - 3.1, Opera 9.25 */</span></span><br><span class="line">*|html[xmlns*=<span class="string">&quot;&quot;</span>] #catorce &#123; <span class="attr">color</span>: red  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Everything but IE6-8 */</span></span><br><span class="line">:root *&gt; #quince &#123; <span class="attr">color</span>: red  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IE7 */</span></span><br><span class="line">*+html #dieciocho &#123;  <span class="attr">color</span>: red &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Firefox only. 1+ */</span></span><br><span class="line">#veinticuatro,  <span class="attr">x</span>:-moz-any-link  &#123; <span class="attr">color</span>: red &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Firefox 3.0+ */</span></span><br><span class="line">#veinticinco,  <span class="attr">x</span>:-moz-any-link, <span class="attr">x</span>:<span class="keyword">default</span>  &#123; <span class="attr">color</span>: red  &#125;</span><br></pre></td></tr></table></figure></li>
<li>属性hack:不同浏览器解析bug或方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IE6 */</span></span><br><span class="line">#once &#123; <span class="attr">_color</span>: blue &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IE6, IE7 */</span></span><br><span class="line">#doce &#123; *color: blue; <span class="comment">/* or #color: blue */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Everything but IE6 */</span></span><br><span class="line">#diecisiete &#123; color<span class="comment">/**/</span>: blue &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IE6, IE7, IE8 */</span></span><br><span class="line">#diecinueve &#123; <span class="attr">color</span>: blue\<span class="number">9</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IE7, IE8 */</span></span><br><span class="line">#veinte &#123; color<span class="comment">/*\**/</span>: blue\<span class="number">9</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IE6, IE7 -- acts as an !important */</span></span><br><span class="line">#veintesiete &#123; <span class="attr">color</span>: blue !ie; &#125; <span class="comment">/* string after ! can be anything */</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="specified-value、computed-value、used-value计算方法"><a href="#specified-value、computed-value、used-value计算方法" class="headerlink" title="specified value、computed value、used value计算方法"></a>specified value、computed value、used value计算方法</h3><ol>
<li>specified value</li>
</ol>
<ul>
<li>如果样式表设置了值，使用这个值</li>
<li>如果没有设置值，该属性是继承属性，则从父元素继承</li>
<li>如果没有设置值也不是继承属性，则使用css规范指定的初始值</li>
</ul>
<ol start="2">
<li>computed value</li>
</ol>
<ul>
<li>以specified value根据规范定义的行为进行计算，通常将相对值计算为绝对值，例如em根据font-size进行计算。</li>
<li>一些使用百分数并且需要布局来决定最终值的属性，如width，margin。</li>
<li>百分数就直接作为computed value。line-height的无单位值也直接作为computed value。这些值将在计算used value时得到绝对值。computed value的主要作用是用于继承</li>
</ul>
<ol start="3">
<li>used value</li>
</ol>
<ul>
<li>属性计算后的最终值，对于大多数属性可以通过window.getComputedStyle(返回的是 CSSStyleDeclaration 对象)获得，尺寸值单位为像素。以下属性依赖于布局<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">background-position</span><br><span class="line">bottom, left, right, top</span><br><span class="line">height, width</span><br><span class="line">margin-bottom, margin-left, margin-right, margin-top</span><br><span class="line">min-height, min-width</span><br><span class="line">padding-bottom, padding-left, padding-right, padding-top</span><br><span class="line">text-indent</span><br></pre></td></tr></table></figure>
<h3 id="Link与-import的区别"><a href="#Link与-import的区别" class="headerlink" title="Link与@import的区别"></a>Link与@import的区别</h3></li>
</ul>
<p><strong>区别</strong></p>
<ol>
<li><p>从属关系区别<br>@import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。</p>
</li>
<li><p>加载顺序区别<br>加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。</p>
</li>
<li><p>兼容性问题<br>@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。</p>
</li>
<li><p>DOM可控性区别<br>可以通过 JS 操作 DOM ，插入link标签来改变样式；由于DOM方法是基于文档的，无法使用@import的方式插入样式。</p>
</li>
</ol>
<h3 id="Display-block与Display-inline的区别"><a href="#Display-block与Display-inline的区别" class="headerlink" title="Display:block与Display:inline的区别"></a>Display:block与Display:inline的区别</h3><ol>
<li><p>display：block将元素显示为块级元素，可以设置width和height属性以及内外边距，每个块级元素独占一行。</p>
</li>
<li><p>display : inline将元素显示为行内元素，高度，行高以及底边距不可改变，高度就是内容文字或者图片的宽度，不可以改变。多个相邻的行内元素排在同一行里并排显示，如果页面一行排列不下，才会换新的一行。width，height，top-bottom margin 等属性不起作用。</p>
</li>
</ol>
<h3 id="PNG、GIF、JPG区别及如何选择"><a href="#PNG、GIF、JPG区别及如何选择" class="headerlink" title="PNG、GIF、JPG区别及如何选择"></a>PNG、GIF、JPG区别及如何选择</h3><ol>
<li><p>jpg是一种有损的基于直接色的图片格式。由于采用直接色，jpg可使用的颜色有1600w之多（2^24），而人眼识别的颜色数量大约只有1w多种，因此jpg非常适合色彩丰富图片、渐变色。jpg有损压缩移除肉眼无法识别的图片细节后，可以将图片的尺寸大幅度地减小。但是jpg不适合icon、logo，因为相比gif/png-8，它在文件大小上丝毫没有优势。</p>
</li>
<li><p>gif采用LZW压缩算法进行编码，是一种无损的基于索引色的图片格式。由于采用了无损压缩，相比古老的bmp格式，尺寸较小，而且支持透明和动画。缺点是由于gif只存储8位索引（也就是最多能表达2^8=256种颜色），色彩复杂、细节丰富的图片不适合保存为gif格式。色彩简单的logo、icon、线框图适合采用gif格式。</p>
</li>
<li><p>png优点:无损压缩、支持透明、简单图片尺寸小；缺点：不支持动画、色彩丰富的图片尺寸大；适用场景：logo/icon/透明图</p>
</li>
</ol>
<h3 id="offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别"><a href="#offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别" class="headerlink" title="offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别"></a>offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别</h3><ol>
<li><p>clientWidth/clientHeight 返回值包含 content + padding，如有滚动条，也不包含滚动条;内容区域的显示大小:对于没有定义CSS或者内联布局盒子的元素为0， 否则，它是元素内部的高度(单位像素)，包含内边距，但不包括水平滚动条、边框和外边距。</p>
</li>
<li><p>scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸;表示一个元素内容区域的实际大小， 包括不在页面中的可滚动部分</p>
</li>
<li><p>offsetWidth 就表示元素的布局宽高，并不代表实际渲染出来的宽高<br>offsetWidth/offsetHeight = content + padding + border<br>CSS 「标准宽高」，它包含了边框、内边距、元素内容 以及滚动条（如果存在的话）。</p>
</li>
</ol>
<h3 id="什么是web语义化，有什么好处"><a href="#什么是web语义化，有什么好处" class="headerlink" title="什么是web语义化，有什么好处"></a>什么是web语义化，有什么好处</h3><p><strong>什么是web语义化</strong><br>Web语义化是指使用恰当语义的html标签、class类名等内容，让页面具有良好的结构与含义，从而让人和机器都能快速理解网页内容。语义化的web页面一方面可以让机器在更少的人类干预情况下收集并研究网页的信息，从而可以读懂网页的内容，然后将收集汇总的信息进行分析，结果为人类所用；另一方面它可以让开发人员读懂结构和用户以及屏幕阅读器（如果访客有视障）能够读懂内容。<br>简单来说就是利于 SEO，便于阅读维护理解。</p>
<p><strong>好处</strong></p>
<ol>
<li>正确的标签做正确的事情</li>
<li>页面内容结构化</li>
<li>无CSS样子时也容易阅读，便于阅读维护和理解</li>
<li>便于浏览器、搜索引擎解析。 利于爬虫标记、利于SEO(搜索引擎)</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="css-sprite"
  class="article article-type-css"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/26/sprite/"
    >CSS sprite</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/26/sprite/" class="article-date">
  <time datetime="2021-01-26T11:57:52.000Z" itemprop="datePublished">2021-01-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="CSS-sprite是什么"><a href="#CSS-sprite是什么" class="headerlink" title="CSS sprite是什么"></a>CSS sprite是什么</h3><p><strong>通常被意译为“CSS图像拼合”或“CSS贴图定位”</strong></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>减少了网页的http的请求，提高了网页性能。原理很简单，没有运用csssprite这种技术时，网页可能要加载十二个icons，但当运用了这种技术之后，十二个icons全部放在一个background-image内了。当我们加载网页的时候就只需要加载一个background-image就可以了。</li>
<li>　CSS Sprites能减少图片的字节，曾经比较过多次3张图片合并成1张图片的字节总是小于这3张图片的字节总和</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>首先一点是维护麻烦，当我们需要的十二个icons需要换其中几个或者增加或删除几个的时候，可能需要重新排版。当修改的icon与之前的不一致时则更几乎是要重新排版的。所以在这一点上，css sprite并不容易维护。不过一般人们运用这种技术的前提是设计的css盒子能够保证在相当长的一段时间内不会改变的。</li>
<li>开发时，在自适应属性下，css sprite可能会因为图片大小等属性的各种原因而导致图片出现断裂情况使得设计的页面效果十分难看。</li>
<li>同样是开发时，在设计页面的时候，运用csssprite技术需要用Photoshop去精准的定位到图片的长度，操作不难但是比较繁琐。</li>
<li>CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景 图片的位置。<br>当页面加载时，不是加载每个单独图片，而是一次加载整个组合图片。这是一个 了不起的改进，它大大减少了HTTP请求的次数，减轻服务器压力，同时缩短了悬停加载图片所需要的时间延迟，使效果更流畅，不会停顿。</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-CSS选择器"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/26/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"
    >CSS选择器</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/26/CSS%E9%80%89%E6%8B%A9%E5%99%A8/" class="article-date">
  <time datetime="2021-01-26T10:55:06.000Z" itemprop="datePublished">2021-01-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><strong>CSS 选择器有许多种，例如 ID 选择器、类选择器、标签选择器、通用选择器、属性选择器、伪类选择器、伪元素选择器、群组选择器、后代选择器、子元素选择器、兄弟元素选择器等等</strong></p>
<p><strong>CSS 几种常见选择器优先级</strong><br><em>!important &gt; 内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通用选择器</em></p>
<h3 id="选择器语法"><a href="#选择器语法" class="headerlink" title="选择器语法"></a>选择器语法</h3><ol>
<li><p>星号—— * </p>
<ul>
<li>通用选择器:可以选择任何元素</li>
</ul>
</li>
<li><p>类型选择器—— type </p>
<ul>
<li>它选择的是元素中的tagName（标签名）属性</li>
<li>我们可以认为类型选择器就是一个简单的文本字符串<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    border:1px solid green</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>类选择器—— .</p>
<ul>
<li>以.开头的选择器就是clas选择器</li>
</ul>
</li>
<li><p>ID选择器—— #</p>
<ul>
<li>以#开头加上id名，这个是严格匹配的</li>
</ul>
</li>
<li><p>属性选择器—— attribute</p>
<ul>
<li>它包括了class属性和id选择器</li>
<li>完整语法是attribute=value，相当于前面是属性名，后面是属性值</li>
<li>如果我们对优先级没有特殊要求的话，我们理论上是可以用属性选择器来代替 class 选择器和 id 选择器的</li>
</ul>
</li>
<li><p>伪类选择器—— :</p>
<ul>
<li>以:开头，他主要是属性的特殊状态</li>
<li>一些伪类选择器是带有函数的伪类选择器，这些我们都是可以去使用伪类来解决的</li>
</ul>
</li>
<li><p>伪元素选择器—— ::</p>
<ul>
<li>一般都是以::开头</li>
<li>实际上是支持使用单冒号的，但是我们提倡双冒号这个写法</li>
<li>因为我们可以一眼就看出这个是伪元素选择器，和伪类区分开来</li>
</ul>
</li>
<li><p>复合选择器</p>
</li>
<li><p>动态伪类选择器:</p>
<ul>
<li>:hover 鼠标悬停</li>
<li>:active 鼠标按下未松开时</li>
<li>:focus 获得焦点的元素</li>
</ul>
</li>
<li><p>结构为类</p>
</li>
</ol>
<p><em>父找子</em></p>
<ul>
<li>:first-child：第一个孩子</li>
<li>:nth-child(n)：第n个孩子</li>
<li>:last-child：最后一个孩子</li>
<li>:only-child：没有任何兄弟元素的元素</li>
</ul>
<p><em>找兄弟中的同类</em></p>
<ul>
<li>:first-of-type：一组兄弟元素中某类型的第一个元素</li>
<li>:nth-of-type(n)：一组兄弟元素中某类型的第n个元素</li>
<li>:last-of-type：一组兄弟元素中某类型的最后一个元素</li>
<li>:only-of-type：没有任何想同类型的兄弟元素的元素</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-观察者模式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/26/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"
    >观察者模式</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/26/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2021-01-26T10:27:36.000Z" itemprop="datePublished">2021-01-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="什么是观察者"><a href="#什么是观察者" class="headerlink" title="什么是观察者"></a>什么是观察者</h3><p><em>观察者模式指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行</em></p>
<h3 id="观察者产生的背景"><a href="#观察者产生的背景" class="headerlink" title="观察者产生的背景"></a>观察者产生的背景</h3><p><em>在软件系统中遇到这类需求：当一个对象的状态发生改变，某些与它相关的对象也要随之做出相应的变化。这是建立一种 对象域对象之前的依赖关系，一个对象发生变化时将自动通知其他对象，其他对象将做出反应。我们将发生改变的对象称为观察目标，将被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互关系，之后可以根据需要增加和删除，系统更易于扩展，这就是观察者模式的产生背景</em></p>
<h3 id="生活场景"><a href="#生活场景" class="headerlink" title="生活场景"></a>生活场景</h3><p><em>所有浏览器事件（鼠标悬浮、按键等）都是观察者模式的例子</em></p>
<h3 id="模式的组成"><a href="#模式的组成" class="headerlink" title="模式的组成"></a>模式的组成</h3><p><strong>在观察着模式中，通常包含以下角色：</strong></p>
<ol>
<li><p>目标（Subject）</p>
</li>
<li><p>观察目标（ConcresteSubject）</p>
</li>
<li><p>观察者（Observer）</p>
</li>
<li><p>具体观察者（ConcreteObserver）</p>
</li>
</ol>
<h3 id="观察者模式的特点"><a href="#观察者模式的特点" class="headerlink" title="观察者模式的特点"></a>观察者模式的特点</h3><p><strong>优点</strong></p>
<ol>
<li>观察者模式可以实现 表示层和数据逻辑层的分离，并降低观察目标和观察者之间的耦合度；</li>
<li>观察者模式支持简单广播通信，自动通知所有已经订阅过的对象；</li>
<li>观察者模式 符合开闭原则的要求；</li>
<li>观察目标和观察者之间的抽象耦合关系能够单独扩展</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>当一个观察目标有多个直接或间接的观察者时，通知所有观察者的过程将会花费很多时间。</li>
<li>当观察目标和观察者之间存在循环依赖时，观察目标会触发他们之间进行循环调用，可能导致系统崩溃。</li>
<li>观察者模式缺少相应机制，让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>在一个抽象模型中，一个对象的行为 依赖于另一个对象的状态。当目标对象的状态发生改变时，会直接影响到观察者的行为；</li>
<li>一个对象需要通知其他对象发生反应，但不知道对象是谁。</li>
</ol>
<h3 id="定义观察目标接口和观察者接口"><a href="#定义观察目标接口和观察者接口" class="headerlink" title="定义观察目标接口和观察者接口"></a>定义观察目标接口和观察者接口</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//观察目标接口</span></span><br><span class="line">interface Subject &#123;</span><br><span class="line">  addObserver: <span class="function">(<span class="params">observer:Observer</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">  deleteObserver:<span class="function">(<span class="params">observver:Observer</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">  notifyObservers:<span class="function">() =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//观察者接口</span></span><br><span class="line">interface Observer &#123;</span><br><span class="line">  notify:<span class="function">() =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-proxy"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/25/proxy/"
    >proxy</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/25/proxy/" class="article-date">
  <time datetime="2021-01-25T11:31:14.000Z" itemprop="datePublished">2021-01-25</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Proxy<br><em>Proxy 是一种构造器，所以是通过new关键字实现的，从功能上讲，也是一种拦截器，在设置对象属性或者读取对象属性时做一层拦截操作。</em><br><em>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">target：用<span class="built_in">Proxy</span>包装的目标对象（可以是任何类型的对象，包括原生数组、函数、甚至另一个代理）</span><br><span class="line">handler ：一个对象，用来定制拦截行为</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;wxp&#x27;</span>&#125;,&#123;</span><br><span class="line">	<span class="function"><span class="title">get</span>(<span class="params">target,key,value,proxy</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>)&#125;,</span><br><span class="line">	<span class="function"><span class="title">set</span>(<span class="params">target,key,value,proxy</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">3</span>)&#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj.name = <span class="number">1</span>;<span class="comment">//当设置对象属性值，打印3</span></span><br><span class="line">obj.name;<span class="comment">//当获取对象，打印2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例</span><br><span class="line">对 set 做拦截，比如规定设置属性值时必须符合某个要求：</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置属性 point 必须是小于0的数字。</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;,&#123;</span><br><span class="line"><span class="function"><span class="title">get</span>(<span class="params">target,key,value,proxy</span>)</span>&#123;&#125;,</span><br><span class="line"><span class="function"><span class="title">set</span>(<span class="params">target,key,value,proxy</span>)</span>&#123;<span class="keyword">if</span>(value&lt;<span class="number">0</span>)&#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;The value seems invalid&#x27;</span>);&#125;&#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj.point = -<span class="number">1</span>;<span class="comment">//报错</span></span><br><span class="line">对 get 做拦截，比如没有某个属性的时候报错：</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有 point 属性的时候报错。</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;<span class="attr">point</span>: <span class="number">2</span>&#125;, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, value, proxy</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> pro <span class="keyword">in</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target[pro]) &#123;</span><br><span class="line">          <span class="keyword">return</span> target[pro]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;The value seems invalid&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;&#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, key, value, proxy</span>)</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">;</span><br><span class="line">obj.age <span class="comment">//报错，没有age这个属性</span></span><br></pre></td></tr></table></figure>
<p>Proxy 支持的拦截操作：</p>
<p>*get(target, propKey, receiver)*：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。<br>*set(target, propKey, value, receiver)*：拦截对象属性的设置，比如proxy.foo =v或proxy[‘foo’] = v，返回一个布尔值。<br>*has(target, propKey)*：拦截propKey in proxy的操作，返回一个布尔值。<br>*deleteProperty(target, propKey)*：拦截delete proxy[propKey]的操作，返回一个布尔值。<br>*ownKeys(target)*：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。<br>*getOwnPropertyDescriptor(target, propKey)*：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。<br>*defineProperty(target, propKey,propDesc)*：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。<br>*preventExtensions(target)*：拦截Object.preventExtensions(proxy)，返回一个布尔值。<br>*getPrototypeOf(target)*：拦截Object.getPrototypeOf(proxy)，返回一个对象。<br>*isExtensible(target)*：拦截Object.isExtensible(proxy)，返回一个布尔值。<br>*setPrototypeOf(target, proto)*：拦截Object.setPrototypeOf(proxy,proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。<br>*apply(target, object, args)*：拦截 Proxy实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。<br>*construct(target, args)*：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-闭包"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/19/%E9%97%AD%E5%8C%85/"
    >闭包</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/19/%E9%97%AD%E5%8C%85/" class="article-date">
  <time datetime="2021-01-19T10:59:06.000Z" itemprop="datePublished">2021-01-19</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="浅谈闭包"><a href="#浅谈闭包" class="headerlink" title="浅谈闭包"></a>浅谈闭包</h1><p><em>闭包的含义</em></p>
<ol>
<li>闭包就是能够读取其他函数内部变量的函数</li>
<li>例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成”定义在一个函数内部的函数”。</li>
<li>在本质上，闭包是将函数内部和函数外部连接起来的桥梁</li>
</ol>
<p><em>为什么使用闭包</em></p>
<ol>
<li>全局变量：可以重复使用，但是会造成全局污染而且容易篡改</li>
<li>局部变量：仅函数内使用不会造成全局污染也不会被篡改，不能重复使用</li>
<li>所以，全局变量和局部变量的优缺点刚好相对，闭包的出现正好结合了全局变量和局部变量的优点</li>
</ol>
<p><em>何时使用闭包</em></p>
<ol>
<li>重用对象，但是又保护对象不被污染篡改时使用</li>
</ol>
<p><em>闭包的表现形式</em><br>返回一个函数：在JS中非常常见</p>
<p>作为函数参数传递：无论通过什么方法将内部函数传递到它所在作用域外，无论在何处执行这个函数，都会产生闭包</p>
<p>回调函数：在定时器、事件监听、ajax请求等等或任何异步中，只要使用了回调函数，实际上就是在使用闭包</p>
<p><em>闭包举例</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> C = A();</span><br><span class="line">C();<span class="comment">// aaa</span></span><br></pre></td></tr></table></figure>
<p><em>分析</em></p>
<ol>
<li>定义普通函数 A</li>
<li>在 A 中定义普通函数 B</li>
<li>在 A 中返回 B</li>
<li>执行 A，并把 A 的返回结果赋值给变量C</li>
<li>执行 C<br>当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-深浅拷贝"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/18/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"
    >深浅拷贝</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/18/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="article-date">
  <time datetime="2021-01-18T10:03:55.000Z" itemprop="datePublished">2021-01-18</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><em>拷贝有个大前提，是针对对象的操作，当想复制一个对象的时候，才存在浅拷贝深拷贝之分！！</em></p>
<p>浅拷贝的实现方式</p>
<ol>
<li><p>Object.assign()<br>可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。</p>
</li>
<li><p>lodash的clone方法</p>
</li>
<li><p>…操作符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;Kobe&#x27;</span>, <span class="attr">address</span>:&#123;<span class="attr">x</span>:<span class="number">100</span>,<span class="attr">y</span>:<span class="number">100</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2= &#123;... obj1&#125;</span><br><span class="line"></span><br><span class="line">obj1.address.x = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">obj1.name = <span class="string">&#x27;wade&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;obj2&#x27;</span>,obj2)</span><br></pre></td></tr></table></figure></li>
<li><p>Array.prototype.concat</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr3 = arr.concat(arr2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123; <span class="attr">username</span>: <span class="string">&#x27;kobe&#x27;</span> &#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = arr.concat();</span><br><span class="line"></span><br><span class="line">arr2[<span class="number">2</span>].username = <span class="string">&#x27;wade&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure></li>
<li><p>Array.prototype.slice</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123;</span><br><span class="line"></span><br><span class="line">username: <span class="string">&#x27; kobe&#x27;</span></span><br><span class="line">     </span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr3 = arr.slice();</span><br><span class="line"></span><br><span class="line">arr3[<span class="number">2</span>].username = <span class="string">&#x27;wade&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><em>深拷贝的实现方式</em></p>
<ol>
<li>JSON.parse(JSON.stringify())</li>
</ol>
<p>可以处理数组和对象的深拷贝，但是不能处理函数和正则，因为这两者基于这两个函数处理后得到的结果不再是正则/函数</p>
<p>缺点：</p>
<p>会忽略undefined</p>
<p>会忽略symbol<br>不能序列化函数<br>不能解决循环引用的对象</p>
<ol start="2">
<li><p>lodash的cloneDeep函数</p>
</li>
<li><p>jQuery.extend函数</p>
</li>
<li><p>如果所拷贝的对象含有内置对象，但是不包含函数，可以使用messagechannel，可以拷贝undefined和循环引用的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">structuralClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; port1, port2 &#125; = <span class="keyword">new</span> MessageChannel()</span><br><span class="line">      </span><br><span class="line">port2.onmessage = <span class="function"><span class="params">ev</span> =&gt;</span> resolve(ev.data)</span><br><span class="line">      </span><br><span class="line">port1.postMessage(obj)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">obj.b.d = obj.b</span><br></pre></td></tr></table></figure>
<p>注意该方法是异步的 可以处理 undefined 和循环引用对象 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clone = <span class="keyword">await</span> structuralClone(obj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(clone)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<p>手写浅拷贝：遍历=&gt;直接等号赋值</p>
</li>
</ol>
<p>浅拷贝 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">name</span> : <span class="string">&#x27;深深地&#x27;</span>, <span class="attr">arr</span> : [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>], &#125;;</span><br><span class="line"> <span class="keyword">let</span> obj3=shallowClone(obj1)</span><br><span class="line">obj3.name = <span class="string">&quot;春娇&quot;</span>; obj3.arr[<span class="number">1</span>] = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] ;</span><br></pre></td></tr></table></figure>
<p> 新旧对象还是共享同一块内存</p>
<p>这是个浅拷贝的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">shallowClone</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> source) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (source.hasOwnProperty(i)) &#123;</span><br><span class="line">    </span><br><span class="line">        target[i] = source[i];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> target;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;obj1&#x27;</span>,obj1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;obj3&#x27;</span>,obj3)</span><br></pre></td></tr></table></figure>
<p>obj.hasOwnProperty，返回值是一个布尔值，即是否是obj的属性（原型上的是false)</p>
<p>深拷贝 遍历，如果是简单数据类型直接赋值，如果是复杂数据类型递归。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Promise"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/15/Promise/"
    >Promise</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/15/Promise/" class="article-date">
  <time datetime="2021-01-15T11:23:56.000Z" itemprop="datePublished">2021-01-15</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><em>Promise含义与作用</em></p>
<ol>
<li>Promise是异步的容器，本身是同步，里面可以写异步的</li>
<li>Promise主要解决异步问题：定时器，网络请求，数据库</li>
<li>Promise有两个参数，resolve:解析  reject:失败</li>
</ol>
<p><em>手写Promise</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">         resolve(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">     &#125;, <span class="number">0</span>)</span><br><span class="line"> &#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(data)</span><br><span class="line"> &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;失败了&#x27;</span>)</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="comment">//分析：成功then函数执行，失败catch函数执行</span></span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-HTTPS协议"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/14/HTTPS%E5%8D%8F%E8%AE%AE/"
    >HTTPS协议</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/14/HTTPS%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2021-01-14T11:11:39.000Z" itemprop="datePublished">2021-01-14</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><em>为什么要用HTTPS</em></p>
<ol>
<li>HTTP协议以明文方式传递信息，不提供任何方式的加密，不适合传输一些敏感信息，比如：各种账号，密码等信息，使用HTTP协议传输非常不安全；</li>
<li>为了解决上述存在的问题，所以出现了HTTPS；HTTPS 协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性；解决了 HTTP 存在的缺点问题。</li>
</ol>
<p><em>什么是HTTPS</em></p>
<ol>
<li>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL/TLS，通过 SSL 证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。</li>
<li>HTTPS 是一种通过计算机网络进行安全通信的传输协议，经由 HTTP 进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS 使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。</li>
</ol>
<p><em>SSL是什么</em></p>
<ol>
<li>SSL（Secure Socket Layer，安全套接字层）：SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</li>
<li>TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，目前使用最广泛的是TLS 1.1、TLS 1.2。</li>
</ol>
<p><em>浏览器在使用HTTPS传输数据的流程是什么</em></p>
<ol>
<li>首先客户端通过 URL 访问服务器建立 SSL 连接。</li>
<li>服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。</li>
<li>客户端的服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级。</li>
<li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</li>
<li>服务器利用自己的私钥解密出会话密钥。</li>
<li>服务器利用会话密钥加密与客户端之间的通信。</li>
</ol>
<p><em>HTTPS的特点</em></p>
<ol>
<li>采用混合加密技术，中间者无法直接查看明文内容</li>
<li>通过证书认证客户端访问的是自己的服务器（确认网站的真实性）</li>
<li>防止传输的内容被中间人冒充或者篡改</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我的</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>